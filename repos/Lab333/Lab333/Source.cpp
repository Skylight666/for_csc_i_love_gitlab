/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/
#include<iostream>
#include<cstdlib>
#include<ctime>
#include<string>
#include<vld.h>
#include<limits>

#define	  stop __asm nop

int main()
{
	srand(time(0));
	/*
	///////////////////////////////////////////////////////////////
	//			Встроенные массивы                               //
	///////////////////////////////////////////////////////////////





		
		//Задание 1. Объявите трехмерный N*M*K массив и сформируйте указанные
		//значения элементов следующим образом:
		//а) проинициализируйте массив при объявлении
	*/
		const int N = 3, M = 3, K = 3;

		int arr1[N][M][K] =
		{
			{{1, 1, 1}, {1,1,1}, {1,1,1}},
			{{2, 2, 2}, {2,2,2}, {2,2,2}},
			{{3, 3, 3}, {3,3,3}, {3,3,3}}
		} ;

		//б)* объявите неинициализированный массив и присвойте значения элементам
		//	с помощью кода
		//					 |--------|
		//				   / |3  3  3 |
		//    			 |---------|3 |
		//			   / | 2  2  2 |3 |
		//			  |---------|2 |__|
		//			  | 1  1  1 |2 | /
		//			  | 1  1  1 |__|
		//			  | 1  1  1 | /
		//			  |_________|

		int arr2[N][M][K];
		int * p = &arr2[0][0][0];
		for (int i = 0; i < N*M*K; i++) 
		{
			if (i < 9)
			{
				*p = 1;
				p++;
			}
			else
			{
				if (i < 18)
				{
					*p = 2;
					p++;
				}
				else
				{
					*p = 3;
					p++;
				}
			}
		}

		stop
			//Средствами отладчика проверьте правильность Вашего решения.

			//в) найдите сумму элементов массива

		int summ = 0;
		int *p1 = &arr1[0][0][0];
		for (int i = 0; i < (sizeof(arr1) / sizeof(arr1[0][0][0])); i++)
		{
			summ += *p1;
			p1++;
		}
		std::cout << summ << std::endl;
		stop;

		//г) проинициализируйте массив при определении:
		//					 |--------|
		//				   / |3  0  0 |
		//    			 |---------|0 |
		//			   / | 2  0  0 |0 |
		//			  |---------|0 |__|
		//			  | 1  0  0 |0 | /
		//			  | 0  0  0 |__|
		//			  | 0  0  0 | /
		//			  |_________|

		short arr3[N][M][K] =
		{
			{1},
			{2},
			{3}
		};
		stop;

		//д)* Инициализация массивов строковыми литералами:
		//Объявите и проинициализируйте строковыми литералами два массива:
		//двухмерный массив и массив указателей. Поясните разницу в использовании
		//элементов таких массивов.

		char arr4[4][20];
		for (int i = 0; i < 4; i++)
		{
			std::cin >> arr4[i];
			std::cout << arr4[i];
		}
		printf("\n");
		stop;

		const char* arr5[3] = {"str1", "str2", "str3" };

			std::cout << *arr5[0];
		stop;





			///////////////////////////////////////////////////////////////
			//			Динамическое выделение памяти                    //
			///////////////////////////////////////////////////////////////
		//Задание2. Создайте динамический двухмерный массив с размерностями,
		//вычисляемыми в процессе выполнения программы - N*M.
		//Задайте значения элементов помощью генератора случайных чисел.
		//Найдите  сумму элементов.
		//Подсказка 1: для генерации случайных чисел используйте функцию
		//стандартной библиотеки - rand() (<cstdlib>)
		//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
		//чисел являются «псевдослучайными», то есть при двух последовательных запусках
		//приложения Вы получаете две одинаковые последовательности значений.
		//Для того чтобы генерируемые "случайные" значения были разными при каждом
		//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
		//и time() (<ctime>).
		//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
		//Функция time() задает эту точку отсчета, считывая текущее время




		unsigned int n, m = 0;

			

			n = rand() % 10 + 1;
			m = rand() % 10 + 1;
			//int * p = new int[n*m];
			int ** pp = new int* [n];

			for (int i = 0; i < n; i++)
				pp[i] = p + m * i;

			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < m; j++)
				{
					pp[i][j] = rand() % 21 - 10;
					std::cout << pp[i][j] << " ";
				}
				std::cout << std::endl;
			}
			stop;

			unsigned long long int sum = 0;
			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < m; j++)
				{
					sum += pp[i][j];
				}
			}
			std::cout << "\n" << sum;
			stop;
		//Задание2а. В сформированном массиве отсортируйте каждую строку по
		//убыванию значений. Используйте сортировку "выбором"
		printf("\n \n");
			int temp = 0;
			for (int i = 0; i < n; i++)
			for (int j = 0; j < m-1; j++)
			{
				int min = j;
				for (int k = j + 1; k < m; k++)
				{
					if (pp[i][k] < pp[i][min])
						min = k;
				}
				temp = pp[i][j];
				pp[i][j] = pp[i][min];
				pp[i][min] = temp;
			}



			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < m; j++)
				{
					std::cout << pp[i][j] << " ";
				}
				std::cout << std::endl;
			}
			stop;
		//Задание2б. Объявите одномерный массив размерностью N.
		//Сформируйте значение i-ого элемента одномерного массива
		//равным среднему значению элементов i-ой строки
		//двухмерного массива

			double * arrd = new double[n];

			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < m; j++)
				{
					sum += pp[i][j];
				}
				arrd[i] = static_cast<double>(sum) / m;
				sum = 0;
			}
			delete[]arrd;
			delete[] pp;

		//Подсказка - не забудьте освободить память!





		/////////////////////////////////////////////////////////////////////
		//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
		//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
		//упорядочивая полученное значение по возрастанию


			int tmp = 0;
			const short NN = 10;
			int arr[NN];
			int indx = 0;

			std::cout << "\n";

			std::cin >> arr[0];

			for (int k = 1; k < NN; k++)
			{

				std::cin >> arr[k];
				for (int i = 1; i < k + 1; ++i)
				{
					for (int r = 0; r < k + 1 - i; r++)
					{
						if (arr[r] < arr[r + 1])
						{
							int tmp = arr[r];
							arr[r] = arr[r + 1];
							arr[r + 1] = tmp;
						}
					}
				}
			}


			for (int i = 0; i<NN; i++) 
			{
				std::cout << arr[i] << " ";

			}
			stop;

		//б) Простой поиск.
		//Модифицируйте предыдущее задание следующим образом:очередное значение
		//вводится в массив только при условии, что там еще такого нет (то есть
		//дубли игнорируются

			int left = 0, right = NN, midd = 0, key = 0;

			bool flag = true; 

			std::cin >> arr[0];
			arr[NN] = {0};

			for (int i = 1; i < NN; i++)
			{

				std::cin >> key;
				for (int j = 0; j < i; j++)
				{
					while (arr[j] == key)
					{
						std::cout << "Try again" << "\n";
						std::cin >> key;
						j = 0;
					}

				}

				arr[i] = key;
				
			}

			

			for (int i = 0; i<NN; i++) 
			{
				std::cout << arr[i] << " ";
			}
			stop;




		///////////////////////////////////////////////////////////////////////////
		//Задание 4*.С помощью данной заготовки напишите программу,
		//которая:
		//вводит строки с клавиатуры с помощью cin>>...
		//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
		//признаком конца ввода является символ * (то есть строка - "*") или
		//заполнение массива (больше свободных строк нет);
		//сортировка строк в алфавитном порядке. Пояснение: крайне
		//не рекомендуется для сортировки сложных объектов физически
		//перемещать их в памяти. Намного эффективнее завести массив
		//указателей на соответствующие строки и перемещать только
		//указатели.

		//Подсказка: для лексиграфического сравнения строк пользуйтесь
		//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.


		//Определите необходимые значения как константы
	 //STOP_STRING  -  "*"	//признак "прекратить ввод"
	 //M  -  80	//максимальный размер одной строки
	 //N  -  10	//максимальное количество строк в массиве

	#define STOP_STRING ('*')
		const short C = 5;
		const short B = 80;



		//Объявите двухмерный массив с именем cBuffer типа char и
		// размерностью N*M

		char cBuffer[C][B] = {0};


		//Объявите массив (с именем cPointers) указателей на строки
		//размерностью N

		char* cPointers[B];

			//Цикл ввода строк:
			//а) выведите приглашение для ввода
			//б) пока не введена строка STOP_STRING или не заполнен весь массив

			//strcnp сравнивает строки и выдает значение, равное нулю, в том случае

			//ввод строки в массив cBuffer:

			//если введена строка - признак окончания, то выйти из цикла

			//Присвойте элементу массива cPointers с индексом nIndex
			//указатель на строку с номером nIndex в массиве cBuffe
			//Выдать диагностику о том, что прием строк завершен.

			//Теперь сортируем строки:

			//Цикл сортировки строк по методу "всплывающего пузырька" в
			//порядке возрастания. На каждой итерации - промежуточная печать
			//отсортированных строк




		for (int i = 0; i < C; i++)
		{
			cPointers[i] = cBuffer[i];

			std::cout << "\nEnter the string " << i+1 << ":" << std::endl;
			int j = 0;

			while ((j < B) && ((cBuffer[i][j]) != STOP_STRING))
			{
				std::cin >> cBuffer[i][j];



				if (cBuffer[i][j] == STOP_STRING)
					break;

				j++;

			}

		}

		char * tmpCH;
		std::cout << std::endl;
		for (int i = 0; i < C; i++)
		{
			for (int j = C - 1; j > i; j--)
			{
				if (strcmp(cPointers[j], cPointers[j - 1]) < 0)
				{
					tmpCH = cPointers[j];
					cPointers[j] = cPointers[j - 1];
					cPointers[j - 1] = tmpCH;
					stop;
				}
			}
			std::cout  << cPointers[i] << std::endl;
		}
		stop;




		//Задание 5*. Реализуйте задание №4, используя не встроенные,
		//а динамические массивы (массив?). Так как строки могут быть разной длины,
		//эффективным решением было бы отводить под каждую строку ровно столько байтов,
		//сколько требуется для ее хранения.
		//При этом необходимые параметры (количество строк
		// сформируйте с помощью потока ввода

		int strLength = 255;
		int dataCount = 5;

		// Initialize array of char array
		char ** arr_of_str = new char*[dataCount];
		for (int i = 0; i < dataCount; i++)
			arr_of_str[i] = new char[strLength];



		for (int i = 0; i < C; i++)
		{

			std::cout << "\nEnter the string " << i + 1 << ":" << std::endl;
			int j = 0;

			while ((j < B) && ((arr_of_str[i][j]) != STOP_STRING))
			{
				std::cin >> arr_of_str[i][j];



				if (arr_of_str[i][j] == STOP_STRING)
					break;

				j++;

			}

		}

		std::cout << std::endl;
		for (int i = 0; i < C; i++)
		{
			for (int j = C - 1; j > i; j--)
			{
				if (strcmp(arr_of_str[j], arr_of_str[j - 1]) < 0)
				{
					tmpCH = arr_of_str[j];
					arr_of_str[j] = arr_of_str[j - 1];
					arr_of_str[j - 1] = tmpCH;
					stop;
				}
			}
		}
		stop;


		//Цикл ввода строк:

		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания кода первого символа





		//Освобождение занятой памяти:

		for (int i = 0; i < dataCount; i++)
		{
			delete[] arr_of_str[i];
		}
		delete[] arr_of_str;





		//Задание 6*. Объявление и использование указателей на многомерные
		// массивы. Проинициализируйте трехмерный массив
		//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
		//кода, который меняет местами значения элементов четных
		//и нечетных слоев:


		/*for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{

				}
			}
			}

		*/

		//	было:			     |--------|		
		//  				   / |4  4  4 |		
		//					 |--------|	4 |	
		//				   / |3  3  3 |	4 |	
		//    			 |---------|3 |   |
		//			   / | 2  2  2 |3 | /
		//			  |---------|2 |__|
		//			  | 1  1  1 |2 | /
		//			  | 1  1  1 |__| 
		//			  | 1  1  1 | /
		//			  |_________|

		//	стало:			     |--------|		
		//  				   / |3  3  3 |		
		//					 |--------|	3 |	
		//				   / |4  4  4 |	3 |	
		//    			 |---------|4 |   |
		//			   / | 1  1  1 |4 | /
		//			  |---------|1 |__|
		//			  | 2  2  2 |1 | /
		//			  | 2  2  2 |__| 
		//			  | 2  2  2 | /
		//			  |_________|


	double darray[4][3][3] =
	{
	{ { 1, 1, 1 },{ 1,1,1 },{ 1,1,1 } },
	{ { 2, 2, 2 },{ 2,2,2 },{ 2,2,2 } },
	{ { 3, 3, 3 },{ 3,3,3 },{ 3,3,3 } },
	{ { 4, 4, 4 },{ 4,4,4 },{ 4,4,4 } }
	};


	double(*dpp_1)[3];
	double(*dpp_2)[3];
	stop;



	for (int i = 0; i < 3; i += 2)
	{

		dpp_1 = darray[i];
		dpp_2 = darray[i + 1];

		for (int j = 0; j < 3; j++)
		{
			for (int k = 0; k < 3; k++)
			{
				double tmp6 = dpp_1[j][k];
				dpp_1[j][k] = dpp_2[j][k];
				dpp_2[j][k] = tmp6;
			}
		}


	}

	stop




		///////////////////////////////////////////////////////////////////////////
		//Задание 7а. Объявите двухмерный встроенный массив элементов типа char.
		//Сформируйте значения элементов массива с помощью генератора случайных 
		//чисел таким образом, чтобы в массиве были только символы '*' и '_'  


		//В каждой строке "сдвиньте звездочки" в начало строки, например:
		//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
		//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
		//и распечатайте массив по строкам - "постройте распределение"



	const short nnnn = 6, mmmm = 6;
	int temp7a = 0;
	char arrr7[nnnn][mmmm];
	char * p77 = &arrr7[0][0];


	for (int i = 0; i < nnnn*mmmm; i++)
	{
		short t = rand() % 2;
		p77[i] = ((rand() % 2) ? '*' : '_');
	}




	for (int i = 0; i < nnnn; i++)
	{
		for (int k = 0; k < mmmm; k++)
		{
			for (int j = mmmm - 1; j > k; j--)
			{


				if (arrr7[i][j] < arrr7[i][j - 1])
				{
					temp7a = arrr7[i][j];
					arrr7[i][j] = arrr7[i][j - 1];
					arrr7[i][j - 1] = temp7a;
				}
			}
		}
	}

	for (int i = 0; i < nnnn; i++)
	{
		for (int j = 0; j < mmmm; j++)
		{
			std::cout << "'" << arrr7[i][j] << "'" << "\t";
		}
		std::cout << std::endl;
	}

	stop;


	// 7б. Модифицируйте предыдущее задание следующим способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"



	const short nnn = 6, mmm = 6;
	int temp7aa = 0;
	char arr7[nnn][mmm];
	char * p7 = &arr7[0][0];


	for (int i = 0; i < nnn*mmm; i++)
	{
		short t = rand() % 2;
		p7[i] = ((rand() % 2) ? '*' : '_');
	}


	for (int i = 0; i < nnn*mmm; i++)


		temp7aa = 0;


	for (int j = 0; j < mmm; j++)
	{
		for (int k = nnn - 1; k > 0; k--)
		{
			for (int i = 0; i < k; i++)
			{
				if (arr7[i][j] < arr7[i + 1][j])
				{
					temp7aa = arr7[i][j];
					arr7[i][j] = arr7[i + 1][j];
					arr7[i + 1][j] = temp7aa;
				}
			}

		}

	}


	for (int i = 0; i < nnn; i++)
	{
		for (int j = 0; j < mmm; j++)
		{
			std::cout << "'" << arr7[i][j] << "'" << "\t";
		}
		std::cout << std::endl;
	}

	stop;

	return 0;
}